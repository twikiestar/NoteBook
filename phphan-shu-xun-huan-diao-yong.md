现有数据库

id                   recommendId

1                             0

2                             1

3                             1

4                             2

5                             3



根据分析得知id为1的用户是id2和id3的推荐人，但是这套系统的初衷其实并不是点对点的结构，其实这是一个金字塔形的数据结构

就是1-&gt;2,3-&gt;4,5 

id2,3是id1的第一级下线

id4,5则是id1的二级下线

所以这里存在一个循环查询下线的功能

思路：

客户想要查看自己名下有多少的人，【查询者的id】

表中查询recommendID为【查询者id】的数据，这查询出来的是第一层的下线，【查询者ID】

查询返回的数据是一个二维数组，进行Foreach循环获取查询出来的id【这是第一层下线的所有id】

然后我们又要再一次foreach再次查询这里问题就是出现了，我们不可能再这个地方再次循环嵌套foreach，不是不可以是，实现不了我们的需求

所以我们要在方法开始前写一个函数，或者在框架的公共函数中写一个自调函数，第一层foreach中调用这个自调函数就能实现我们的需求

这个自调函数的原理是

查询recommendID=【foreach】传入的id -&gt;if\(return false\)-&gt;把当前的数据写入一个数组返回

-else

-&gt;if\(true\)-&gt;数据写入array中-&gt;调用本身self：：function（）再次进行查询

以上的操作均是获取id的操作

然后再次查询所有的用户获取当前用户所有的下线用户



实际上这个操作是非常消耗mysql的数据库的资源的，而且在人数达到百万级别的时候，可能突破php文件运行的最大限制，导致程序终止，其实我们在用户交互生成新用户的时候就可以跟着在数据库中插入当前用户的层数，以及所有上级用户，下级用户的id

